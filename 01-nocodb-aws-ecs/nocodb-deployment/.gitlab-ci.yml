stages:
  - bucket
  - rds
  - prepare
  - deploy
  - loadtest
  - destroy

# Étape 1 : Création du bucket S3
create_bucket_s3:
  stage: bucket
  image:
    name: hashicorp/terraform:1.7.5
    entrypoint: [""]
  script:
    - cd bucket_S3
    - terraform init
    - terraform apply -auto-approve

# Étape 2 : Création de RDS + ECR + VPC + ALB + Certificat ACM
create_rds_ecr:
  stage: rds
  image: alpine:latest
  before_script:
    - apk add --no-cache curl bash unzip
    - curl -LO https://releases.hashicorp.com/terraform/1.7.5/terraform_1.7.5_linux_amd64.zip
    - unzip terraform_1.7.5_linux_amd64.zip
    - mv terraform /usr/local/bin/
  script:
    - cd RDS
    - terraform init
    - terraform apply -auto-approve
    - echo "ECR_IMAGE=$(terraform output -raw ecr_repository_url)" >> ../deployment.env
    - echo "RDS_ENDPOINT=$(terraform output -raw rds_endpoint)" >> ../deployment.env
    - echo "PRIVATE_A=$(terraform output -raw private_subnet_a_id)" >> ../deployment.env
    - echo "PRIVATE_B=$(terraform output -raw private_subnet_b_id)" >> ../deployment.env
    - echo "NOCODB_SG=$(terraform output -raw nocodb_security_group_id)" >> ../deployment.env
    - echo "ECS_TG_ARN=$(terraform output -raw ecs_target_group_arn)" >> ../deployment.env
    - echo "ALB_DNS_NAME=$(terraform output -raw alb_dns_name)" >> ../deployment.env

  artifacts:
    paths:
      - deployment.env
  when: manual


# Étape 3 : Transfert de l'image ECR (facultatif)
send_ecr_url_to_other_repo:
  stage: prepare
  image: curlimages/curl:latest
  script:
    - echo "ECR_IMAGE=$ECR_IMAGE"
    - |
      curl --request POST \
        --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
        "https://gitlab.com/api/v4/projects/70396100/variables" \
        --form "key=ECR_IMAGE" \
        --form "value=$ECR_IMAGE"
  when: manual

# Étape 4 : Déploiement ECS avec auth sécurisée (commande en une seule ligne)
deploy_to_ecs:
  stage: deploy
  image:
    name: hashicorp/terraform:1.7.5
    entrypoint: [""]
  dependencies:
    - create_rds_ecr
  before_script:
    - source deployment.env
  script:
    - terraform init
    - terraform apply -auto-approve -var="ecr_image=${ECR_IMAGE}:latest" -var="rds_endpoint=${RDS_ENDPOINT}" -var="private_subnet_a_id=${PRIVATE_A}" -var="private_subnet_b_id=${PRIVATE_B}" -var="nocodb_security_group_id=${NOCODB_SG}" -var="ecs_target_group_arn=${ECS_TG_ARN}" -var="jwt_secret=${NOCODB_JWT_SECRET}"
  when: manual

# Étape 5 : Test de charge avec Locust
load_test:
  stage: loadtest
  image: python:3.11
  dependencies:
    - create_rds_ecr          
  before_script:
    - source deployment.env    
    - pip install locust
  script:
    - |
      cat > locustfile.py <<EOF
      from locust import HttpUser, task, between

      class User(HttpUser):
          wait_time = between(1, 2)

          @task
          def root(self):
              self.client.get('/')
      EOF
    - locust -f locustfile.py --host=https://quickdata-db.cloud --headless -u 10 -r 2 -t 30s
  when: manual
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging"'
      when: manual
    - when: never


destroy_infra:
  stage: destroy
  image:
    name: hashicorp/terraform:1.7.5
    entrypoint: [""]
  dependencies:
    - create_rds_ecr
  before_script:
    - apk add --no-cache jq aws-cli
    - source deployment.env
  script:
    - terraform init -backend-config="bucket=my-nocodb-tf-state-secondjunko" -backend-config="key=state/terraform.tfstate" -backend-config="region=eu-west-3" && terraform destroy -auto-approve -var="ecr_image=${ECR_IMAGE}:latest" -var="rds_endpoint=${RDS_ENDPOINT}" -var="private_subnet_a_id=${PRIVATE_A}" -var="private_subnet_b_id=${PRIVATE_B}" -var="nocodb_security_group_id=${NOCODB_SG}" -var="ecs_target_group_arn=${ECS_TG_ARN}" -var="jwt_secret=${NOCODB_JWT_SECRET}"
    - cd RDS && terraform init -backend-config="bucket=my-nocodb-tf-state-secondjunko" -backend-config="key=state/rds.tfstate" -backend-config="region=eu-west-3" && terraform destroy -auto-approve -var="db_username=mydb" -var="aws_region=eu-west-3" && cd ..
  when: manual
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging"'
      when: manual
    - when: never
